{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */function () {\n  function QueryManager(options) {\n    var _this = this;\n    this.clientAwareness = {};\n    // All the queries that the QueryManager is currently managing (not\n    // including mutations and subscriptions).\n    this.queries = new Map();\n    // Maps from queryId strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.fetchCancelFns = new Map();\n    this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.inFlightLinkObservables = new Trie(false);\n    this.noCacheWarningsByQueryId = new Set();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    },\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    var documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(27));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n      var _c, _d;\n      var mutation = _b.mutation,\n        variables = _b.variables,\n        optimisticResponse = _b.optimisticResponse,\n        updateQueries = _b.updateQueries,\n        _e = _b.refetchQueries,\n        refetchQueries = _e === void 0 ? [] : _e,\n        _f = _b.awaitRefetchQueries,\n        awaitRefetchQueries = _f === void 0 ? false : _f,\n        updateWithProxyFn = _b.update,\n        onQueryUpdated = _b.onQueryUpdated,\n        _g = _b.fetchPolicy,\n        fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g,\n        _h = _b.errorPolicy,\n        errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h,\n        keepRootFields = _b.keepRootFields,\n        context = _b.context;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            invariant(mutation, 28);\n            invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              fetchPolicy: fetchPolicy,\n              errorPolicy: errorPolicy,\n              context: context,\n              updateQueries: updateQueries,\n              update: updateWithProxyFn,\n              keepRootFields: keepRootFields\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0\n              }), variables, {}, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: isOptimistic ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  // Since mutations might receive multiple payloads from the\n                  // ApolloLink chain (e.g. when used with @defer),\n                  // we resolve with a SingleExecutionResult or after the final\n                  // ExecutionPatchResult has arrived and we have assembled the\n                  // multipart response into a single result.\n                  if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                    resolve(__assign(__assign({}, storeResult), {\n                      data: self.maskOperation({\n                        document: mutation,\n                        data: storeResult.data,\n                        fetchPolicy: fetchPolicy,\n                        id: mutationId\n                      })\n                    }));\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (isOptimistic) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          // Read the current query result from the store.\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          var update = mutation.update;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n      IGNORE: IGNORE\n    }) : optimisticResponse;\n    if (data === IGNORE) {\n      return false;\n    }\n    this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n    return true;\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable[\"lastQuery\"] = query;\n    this.queries.set(observable.queryId, queryInfo);\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    invariant(options.query, 30);\n    invariant(options.query.kind === \"Document\", 31);\n    invariant(!options.returnPartialData, 32);\n    invariant(!options.pollInterval, 33);\n    var query = this.transform(options.query);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: query\n    })).then(function (result) {\n      return result && __assign(__assign({}, result), {\n        data: _this.maskOperation({\n          document: query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: queryId\n        })\n      });\n    }).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(34));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNames = new Map();\n    var queryNamesAndQueryStrings = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          var queryString = print(_this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(print(document))) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n        if (!included) {\n          var queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n          } else {\n            globalThis.__DEV__ !== false && invariant.warn(36);\n          }\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (options) {\n    var _this = this;\n    var query = options.query,\n      variables = options.variables;\n    var fetchPolicy = options.fetchPolicy,\n      _a = options.errorPolicy,\n      errorPolicy = _a === void 0 ? \"none\" : _a,\n      _b = options.context,\n      context = _b === void 0 ? {} : _b,\n      _c = options.extensions,\n      extensions = _c === void 0 ? {} : _c;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n        return result;\n      });\n    };\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions,\n  // Prefer context.queryDeduplication if specified.\n  deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var _b = this.getDocumentInfo(query),\n      serverQuery = _b.serverQuery,\n      clientQuery = _b.clientQuery;\n    if (serverQuery) {\n      var _c = this,\n        inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n        link = _c.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        })),\n        extensions: extensions\n      };\n      context = operation.context;\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var varJson_1 = canonicalStringify(variables);\n        var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n        observable = entry.observable;\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          observable = entry.observable = concast;\n          concast.beforeNext(function () {\n            inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      var errorPolicy = options.errorPolicy;\n      // If we interrupted this request by calling getResultsFromLink again\n      // with the same QueryInfo object, we ignore the old results.\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && errorPolicy === \"none\") {\n          // Throwing here effectively calls observer.error.\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors && errorPolicy === \"none\") {\n        aqr.data = void 0;\n      }\n      if (hasErrors && errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryId, options,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus, query) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    if (query === void 0) {\n      query = options.query;\n    }\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function (variables) {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\" &&\n      // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n      // this is another way to detect when nothing was done/fetched.\n      sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryId);\n    };\n    this.fetchCancelFns.set(queryId, function (reason) {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.maskOperation = function (options) {\n    var _a, _b, _c;\n    var document = options.document,\n      data = options.data;\n    if (globalThis.__DEV__ !== false) {\n      var fetchPolicy = options.fetchPolicy,\n        id = options.id;\n      var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n      var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {\n        this.noCacheWarningsByQueryId.add(operationId);\n        globalThis.__DEV__ !== false && invariant.warn(37, (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\"));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  };\n  QueryManager.prototype.maskFragment = function (options) {\n    var data = options.data,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function () {\n      return queryInfo.getDiff();\n    };\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n    // Watched queries must opt into overwriting existing data on refetch,\n    // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n    : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign(__assign({}, this.defaultContext), newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };","map":{"version":3,"names":["__assign","__awaiter","__generator","invariant","newInvariantError","equal","execute","addNonReactiveToNamedFragments","hasDirectives","isExecutionPatchIncrementalResult","isExecutionPatchResult","isFullyUnmaskedOperation","removeDirectivesFromDocument","canonicalStringify","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","getGraphQLErrorsFromResult","Observable","asyncMap","isNonEmptyArray","Concast","makeUniqueId","isDocumentNode","isNonNullObject","DocumentTransform","mergeIncrementalData","ApolloError","isApolloError","graphQLResultHasProtocolErrors","ObservableQuery","logMissingFieldErrors","NetworkStatus","isNetworkRequestInFlight","QueryInfo","shouldWriteResult","PROTOCOL_ERRORS_SYMBOL","print","hasOwnProperty","Object","prototype","IGNORE","create","Trie","AutoCleanedWeakCache","cacheSizes","maskFragment","maskOperation","QueryManager","options","_this","clientAwareness","queries","Map","fetchCancelFns","transformCache","queryIdCounter","requestIdCounter","mutationIdCounter","inFlightLinkObservables","noCacheWarningsByQueryId","Set","defaultDocumentTransform","document","cache","transformDocument","link","defaultOptions","queryDeduplication","localState","ssrMode","assumeImmutableResults","dataMasking","documentTransform","concat","defaultContext","onBroadcast","mutationStore","stop","forEach","_info","queryId","stopQueryNoBroadcast","cancelPendingFetches","error","cancel","clear","mutate","_a","arguments","_b","mutationId","mutationStoreValue","isOptimistic","self","_c","_d","mutation","variables","optimisticResponse","updateQueries","_e","refetchQueries","_f","awaitRefetchQueries","updateWithProxyFn","update","onQueryUpdated","_g","fetchPolicy","_h","errorPolicy","keepRootFields","context","_j","label","generateMutationId","transformForLink","transform","getDocumentInfo","getVariables","addExportedVariables","sent","loading","markMutationOptimistic","broadcastQueries","Promise","resolve","reject","getObservableFromLink","result","graphQLErrors","storeResult","errors","markMutationResult","removeOptimistic","subscribe","next","hasNext","data","id","err","networkError","cacheWrites","skipCache","push","dataId","query","incremental","diff","asQuery","optimistic","returnPartialData","mergedData","updateQueries_1","observableQuery","queryName","call","updater","get","currentQueryResult","complete","nextQueryResult","mutationResult","queryVariables","length","results_1","updateCache","write","isFinalResult","modify","fields","value","fieldName","DELETE","include","all","then","recordOptimisticTransaction","globalThis","__DEV__","fetchQuery","networkStatus","fetchConcastWithInfo","concast","promise","getQueryStore","store","info","resetErrors","queryInfo","undefined","has","cacheEntry","hasForcedResolvers","shouldForceResolvers","hasNonreactiveDirective","nonReactiveQuery","clientQuery","serverQuery","name","remove","defaultVars","definitions","map","def","kind","operation","set","watchQuery","notifyOnNetworkStatusChange","observable","queryManager","init","generateQueryId","pollInterval","finally","stopQuery","String","generateRequestId","stopQueryInStore","stopQueryInStoreNoBroadcast","clearStore","discardWatches","reset","getObservableQueries","queryNames","queryNamesAndQueryStrings","legacyQueryOptions","Array","isArray","desc","queryString","add","oq","hasObservers","size","getQuery","setObservableQuery","included","nameOrQueryString","warn","reFetchObservableQueries","includeStandby","observableQueryPromises","resetLastResults","refetch","setDiff","startGraphQLSubscription","extensions","makeObservable","hasErrors","hasProtocolErrors","protocolErrors","observablePromise_1","observer","sub","unsubscribe","removeQuery","delete","notify","getLocalState","deduplication","inFlightLinkObservables_1","operationName","prepareContext","forceFetch","printedServerQuery_1","varJson_1","entry","lookup","beforeNext","of","runResolvers","remoteResult","getResultsFromLink","cacheWriteBehavior","requestId","lastRequestId","linkDocument","markError","markResult","markReady","aqr","ready","defaults","normalized","assign","fromVariables","sourcesWithInfo","fetchQueryByPolicy","sources","cleanupCancelFn","reason","setTimeout","containsDataFromLink","fromLink","includedQueriesById","lastDiff","getDiff","results","batch","onWatchUpdated","watch","watcher","indexOf","operationType","operationId","fragment","fragmentName","refetchWritePolicy","oldNetworkStatus","readCache","resultsFromCache","missing","fromData","partial","onlyRunForcedResolvers","resolved","resultsFromLink","shouldNotify","newContext"],"sources":["C:/xampp/htdocs/fundedprime/frontend/node_modules/@apollo/client/core/QueryManager.js"],"sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument, } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult, } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */ (function () {\n    function QueryManager(options) {\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] ||\n            2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new Trie(false);\n        this.noCacheWarningsByQueryId = new Set();\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.cache = options.cache;\n        this.link = options.link;\n        this.defaultOptions = options.defaultOptions;\n        this.queryDeduplication = options.queryDeduplication;\n        this.clientAwareness = options.clientAwareness;\n        this.localState = options.localState;\n        this.ssrMode = options.ssrMode;\n        this.assumeImmutableResults = options.assumeImmutableResults;\n        this.dataMasking = options.dataMasking;\n        var documentTransform = options.documentTransform;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        this.defaultContext = options.defaultContext || Object.create(null);\n        if ((this.onBroadcast = options.onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(newInvariantError(27));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        return __awaiter(this, arguments, void 0, function (_b) {\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n            var _c, _d;\n            var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h, keepRootFields = _b.keepRootFields, context = _b.context;\n            return __generator(this, function (_j) {\n                switch (_j.label) {\n                    case 0:\n                        invariant(mutation, 28);\n                        invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_j.sent());\n                        _j.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        isOptimistic = optimisticResponse &&\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        this.broadcastQueries();\n                        self = this;\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function (result) {\n                                    if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                                        throw new ApolloError({\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = __assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(__assign(__assign({}, storeResult), { data: self.maskOperation({\n                                                    document: mutation,\n                                                    data: storeResult.data,\n                                                    fetchPolicy: fetchPolicy,\n                                                    id: mutationId,\n                                                }) }));\n                                        }\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (isOptimistic) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\n                                            networkError: err,\n                                        })));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            if (!isExecutionPatchIncrementalResult(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables,\n                });\n            }\n            if (isExecutionPatchIncrementalResult(result) &&\n                isNonEmptyArray(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true,\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = mergeIncrementalData(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables,\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            (mutation.refetchQueries || \"\").length > 0 ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !isExecutionPatchResult(result) ||\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = __assign(__assign({}, result), { data: diff.result });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables, { IGNORE: IGNORE })\n            : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                globalThis.__DEV__ !== false && invariant.error(error);\n            }\n        }, mutation.mutationId);\n        return true;\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n            .promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasClientExports(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                nonReactiveQuery: addNonReactiveToNamedFragments(document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                    { name: \"unmask\" },\n                ], document),\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return __assign(__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) }),\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        observable[\"lastQuery\"] = query;\n        this.queries.set(observable.queryId, queryInfo);\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        invariant(options.query, 30);\n        invariant(options.query.kind === \"Document\", 31);\n        invariant(!options.returnPartialData, 32);\n        invariant(!options.pollInterval, 33);\n        var query = this.transform(options.query);\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: query }))\n            .then(function (result) {\n            return result && __assign(__assign({}, result), { data: _this.maskOperation({\n                    document: query,\n                    data: result.data,\n                    fetchPolicy: options.fetchPolicy,\n                    id: queryId,\n                }) });\n        })\n            .finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(34));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNames = new Map();\n        var queryNamesAndQueryStrings = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNames.set(desc, desc);\n                    queryNamesAndQueryStrings.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    var queryString = print(_this.transform(desc));\n                    queryNames.set(queryString, getOperationName(desc));\n                    queryNamesAndQueryStrings.set(queryString, false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n                    (document && queryNamesAndQueryStrings.has(print(document)))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndQueryStrings.set(queryName, true);\n                    if (document)\n                        queryNamesAndQueryStrings.set(print(document), true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n            queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n                if (!included) {\n                    var queryName = queryNames.get(nameOrQueryString);\n                    if (queryName) {\n                        globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n                    }\n                    else {\n                        globalThis.__DEV__ !== false && invariant.warn(36);\n                    }\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (options) {\n        var _this = this;\n        var query = options.query, variables = options.variables;\n        var fetchPolicy = options.fetchPolicy, _a = options.errorPolicy, errorPolicy = _a === void 0 ? \"none\" : _a, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = graphQLResultHasError(result);\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState\n                .addExportedVariables(query, variables, context)\n                .then(makeObservable);\n            return new Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { return info.notify(); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions, \n    // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\n                extensions: extensions,\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = print(serverQuery);\n                var varJson_1 = canonicalStringify(variables);\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n                observable = entry.observable;\n                if (!observable) {\n                    var concast = new Concast([\n                        execute(link, operation),\n                    ]);\n                    observable = entry.observable = concast;\n                    concast.beforeNext(function () {\n                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n                    });\n                }\n            }\n            else {\n                observable = new Concast([\n                    execute(link, operation),\n                ]);\n            }\n        }\n        else {\n            observable = new Concast([Observable.of({ data: {} })]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\n            var hasErrors = graphQLErrors.length > 0;\n            var errorPolicy = options.errorPolicy;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n            };\n            // In the case we start multiple network requests simulatenously, we\n            // want to ensure we properly set `data` if we're reporting on an old\n            // result which will not be caught by the conditional above that ends up\n            // throwing the markError result.\n            if (hasErrors && errorPolicy === \"none\") {\n                aqr.data = void 0;\n            }\n            if (hasErrors && errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\n        if (query === void 0) { query = options.query; }\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" &&\n                // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n                // this is another way to detect when nothing was done/fetched.\n                sourcesWithInfo.sources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\n        this.fetchCancelFns.set(queryId, function (reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new Concast(this.localState\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n                .then(fromVariables)\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink,\n        };\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff(),\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset(); // Force info.getDiff() to read from cache.\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.maskOperation = function (options) {\n        var _a, _b, _c;\n        var document = options.document, data = options.data;\n        if (globalThis.__DEV__ !== false) {\n            var fetchPolicy = options.fetchPolicy, id = options.id;\n            var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n            var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n            if (this.dataMasking &&\n                fetchPolicy === \"no-cache\" &&\n                !isFullyUnmaskedOperation(document) &&\n                !this.noCacheWarningsByQueryId.has(operationId)) {\n                this.noCacheWarningsByQueryId.add(operationId);\n                globalThis.__DEV__ !== false && invariant.warn(\n                    37,\n                    (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\")\n                );\n            }\n        }\n        return (this.dataMasking ?\n            maskOperation(data, document, this.cache)\n            : data);\n    };\n    QueryManager.prototype.maskFragment = function (options) {\n        var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;\n        return this.dataMasking ?\n            maskFragment(data, fragment, this.cache, fragmentName)\n            : data;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) {\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState\n                    .runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                })\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n            // Watched queries must opt into overwriting existing data on refetch,\n            // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n            : (networkStatus === NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ?\n                1 /* CacheWriteBehavior.OVERWRITE */\n                : 2 /* CacheWriteBehavior.MERGE */;\n        var resultsFromLink = function () {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\n                    };\n                }\n                if (returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"standby\":\n                return { fromLink: false, sources: [] };\n        }\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\nexport { QueryManager };\n//# sourceMappingURL=QueryManager.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}